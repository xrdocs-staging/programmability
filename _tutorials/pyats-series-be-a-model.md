---
published: true
date: '2021-04-29 15:02 +0200'
title: pyATS series - Be a model
position: top
tags:
  - iosxr
  - cisco
  - pyATS
  - Python
author: Antoine Orsoni
excerpt: What's a pyATS model and when to use it
---
{% include toc icon="table" title="Table of Contents" %}
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css">
/*
generated by Pygments <https://pygments.org/>
Copyright 2006-2020 by the Pygments team.
Licensed under the BSD license, see LICENSE for details.
*/
pre { line-height: 125%; margin: 0; font-size: small; }
td.linenos pre { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
span.linenos { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
td.linenos pre.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
body .hll { background-color: #ffffcc }
body { background: #f8f8f8; }
body .c { color: #008800; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #AA22FF; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .ch { color: #008800; font-style: italic } /* Comment.Hashbang */
body .cm { color: #008800; font-style: italic } /* Comment.Multiline */
body .cp { color: #008800 } /* Comment.Preproc */
body .cpf { color: #008800; font-style: italic } /* Comment.PreprocFile */
body .c1 { color: #008800; font-style: italic } /* Comment.Single */
body .cs { color: #008800; font-weight: bold } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #AA22FF; font-weight: bold } /* Keyword.Constant */
body .kd { color: #AA22FF; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #AA22FF; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #AA22FF } /* Keyword.Pseudo */
body .kr { color: #AA22FF; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #00BB00; font-weight: bold } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BB4444 } /* Literal.String */
body .na { color: #BB4444 } /* Name.Attribute */
body .nb { color: #AA22FF } /* Name.Builtin */
body .nc { color: #0000FF } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #00A000 } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #B8860B } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mb { color: #666666 } /* Literal.Number.Bin */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sa { color: #BB4444 } /* Literal.String.Affix */
body .sb { color: #BB4444 } /* Literal.String.Backtick */
body .sc { color: #BB4444 } /* Literal.String.Char */
body .dl { color: #BB4444 } /* Literal.String.Delimiter */
body .sd { color: #BB4444; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BB4444 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BB4444 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BB4444 } /* Literal.String.Single */
body .ss { color: #B8860B } /* Literal.String.Symbol */
body .bp { color: #AA22FF } /* Name.Builtin.Pseudo */
body .fm { color: #00A000 } /* Name.Function.Magic */
body .vc { color: #B8860B } /* Name.Variable.Class */
body .vg { color: #B8860B } /* Name.Variable.Global */
body .vi { color: #B8860B } /* Name.Variable.Instance */
body .vm { color: #B8860B } /* Name.Variable.Magic */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
![pyats_hello2.jpg]({{site.baseurl}}/images/pyats_hello2.jpg){: .align-center}

# Introduction

Ever dreamed of a test framework that could be used across multiple platforms, OS and vendors, which could do regression, sanity and feature testing; already used by thousands of engineers and developers worldwide? Guess what, **it exists, it’s free, and you can start using it right now!**

pyATS (**Py**thon **A**utomated **T**est **S**ystems, to be pronounced "py A. T. S.") was first created as an internal project, to ease the validation of two OS versions. It has been made public in 2017 through **Cisco Devnet**.

This blog post will be the third one of a series on pyATS. Today, we will explore pyATS libraries (also known as Genie), we will use a **model** to collect a sample output and understand when to use this capability.

More use cases are going to be covered in the next posts. 

# Other pyATS episodes

You've missed the first episode? You would like to read more? Below the list of published episodes:

<script src="https://gist.github.com/AntoineOrsoni/60e06bcb2e5e6fdeef9adc62dd8e84fa.js"></script>

# pyATS librairies overview

## pyATS building blocks

pyATS is made of three main building blocks:
- **pyATS**, the core block of this ecosystem. It’s a Python framework which leverages multiple Python libraries such as [Unicon](https://pypi.org/project/unicon/), providing a simplified connection experience to network devices. It supports **CLI**, **NETCONF**, **RESTCONF** and **gRPC**. It enables network engineers and developers to start with small and simple test cases.
- **pyATS libraries** (also known as Genie) which provides everything you need for network testing such as parsers, triggers and APIs. 
- **XPRESSO**, the pyATS Web UI Dashboard.

You can read more about **pyATS ecosystem** in the [official documentation](https://pubhub.devnetcloud.com/media/pyats-getting-started/docs/intro/introduction.html).
{: .notice--info}

**pyATS libraries** are the pyATS **SDK** (**S**oftware **D**evelopment **K**it, a big toolbox) which contains all the tools that you need for **Network Test Automation**. It has been used internally at Cisco since 2010 for our automated testing. Yes! You can use the same tools that we use to automate the validation of your network.

You can read more about **pyATS librairies** in the [official documentation](https://developer.cisco.com/docs/genie-docs/).
{: .notice--info}

## pyATS libraries in a nutshell

* **2800+** parsers accross **11** OS (as of April 2021),
* **32** supported models (more to come about them in a coming episode),
* Multiple tools for Test Harness such as triggers or traffic,
* Ansible and Robot libraries for easy integration with other tools.

You can find supported **parsers** and **models** in the [official documentation](https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/).
{: .notice--info}

# Getting your hands dirty

Enough talking, let's code!

![i was born ready2.jpeg]({{site.baseurl}}/images/i was born ready2.jpeg){: .align-center}

**pyATS installation** has been covered in the [First episode]({{site.url}}/programmability/tutorials/pyats-series-install-and-use-pyats/). Check it out to learn how to install pyATS.

## Parsing a CLI output from a device 

In the previous use case, we saw how we can **collect and parse a CLI output** (`show ip interface brief`). Today, we will see how to **use pyATS models** in order to retrieve a **consistent output** when polling devices running different OS.

In order for everyone to be able to run the code, we will use the [IOS XR always-on sandbox on Cisco Devnet](https://devnetsandbox.cisco.com/RM/Diagram/Index/e83cfd31-ade3-4e15-91d6-3118b867a0dd?diagramType=Topology). Below the sandbox information.

| Key               	| Value                    	|
|-------------------	|--------------------------	|
| IOS XRv 9000 host 	| sandbox-iosxr-1.cisco.com 	|
|     SSH Port      	|     22                 	|
|     Username      	|     admin                	|
|     Password      	|     C1sco12345           	|

Today, to demonstrate the `Learn` capability, we will use a sandbox running another operating system: [IOS XE always-on sandbox on Cisco Devnet](https://devnetsandbox.cisco.com/RM/Diagram/Index/27d9747a-db48-4565-8d44-df318fce37ad?diagramType=Topology). Below, the sandbox information.

| Key               	| Value                    	|
|-------------------	|--------------------------	|
| IOS XE host 	        | ios-xe-mgmt.cisco.com 	|
|     SSH Port      	|     8181                 	|
|     Username      	|     developer            	|
|     Password      	|     C1sco12345           	|

Feel free to adapt the code to use your own device(s).

## Building a testbed

The simplest way to connect to a device is through a pyATS testbed file, written in YAML. This information will be used by **Unicon** to connect to the device and send the requested commands.

You can find the complete documentation on how to build a testbed [here](https://pubhub.devnetcloud.com/media/unicon/docs/user_guide/connection.html).
{: .notice--info}

**testbed.yaml**
{: .notice--primary}
<div class="highlight"><pre><span></span><span class="c1"># Step 0: list of devices</span>
<span class="nt">devices</span><span class="p">:</span>
  <span class="nt">iosxr1</span><span class="p">:</span>
    <span class="c1"># Step 1: OS and Type</span>
    <span class="nt">type</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">iosxr-devnet</span>
    <span class="nt">os</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">iosxr</span>
    <span class="c1"># Step 2: credentials</span>
    <span class="nt">credentials</span><span class="p">:</span>
      <span class="nt">default</span><span class="p">:</span>
        <span class="nt">username</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">admin</span>
        <span class="nt">password</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">C1sco12345</span>
    <span class="c1"># Step 3: connection parameters</span>
    <span class="nt">connections</span><span class="p">:</span>
      <span class="nt">vty</span><span class="p">:</span>
        <span class="nt">protocol</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ssh</span>
        <span class="nt">ip</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">sbx-iosxr-mgmt.cisco.com</span>
        <span class="nt">port</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">8181</span>
  <span class="nt">csr1000v</span><span class="p">:</span>
    <span class="c1"># Step 1: OS and Type</span>
    <span class="nt">type</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">iosxe-devnet</span>
    <span class="nt">os</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">iosxe</span>
    <span class="c1"># Step 2: credentials</span>
    <span class="nt">credentials</span><span class="p">:</span>
      <span class="nt">default</span><span class="p">:</span>
        <span class="nt">username</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">developer</span>
        <span class="nt">password</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">C1sco12345</span>
    <span class="c1"># Step 3: connection parameters</span>
    <span class="nt">connections</span><span class="p">:</span>
      <span class="nt">vty</span><span class="p">:</span>
        <span class="nt">protocol</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ssh</span>
        <span class="nt">ip</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ios-xe-mgmt.cisco.com</span>
        <span class="nt">port</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">8181</span>
</pre></div>

The `testbed.yaml` file is available [here](https://github.com/AntoineOrsoni/xrdocs-how-to-pyats/blob/master/2_multi_os/).
{: .notice--info}

The **testbed construction** has been covered in the [First episode]({{site.url}}/programmability/tutorials/pyats-series-install-and-use-pyats/). Have a look to understand how to build a testbed from scratch

## Why do models exist?

Now, what if you have to collect this output from **multiple devices** running **different OS**? The output might be slightly different. On one operating system (OS), a key could be missing, renamed and/or require an additional command to be correctly populated.

Genie has a tool called `Learn` to accomplish validation accross multiple devices which could be running different OS.

For each `feature`, the operational information is collected by executing **multiple show-commands**, after which that output is parsed and stored into a **Python datastructure**. This structure will be the **same** for any OS supported by the model. Said differently, the Python structure between two OS supported by the model will have the same **nested structure** and the same **keys** (ex: `description`); but probably not the same **values** (ex: `Configured using NETCONF!`).

Below, a diagram of the show-commands sent to the device to fully populate the `Interface` model, for each supported OS.

![pyats_interface_model.png]({{site.baseurl}}/images/pyats_interface_model.png){: .align-center}

You can find all pyATS supported **models** in the [official documentation](https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/models).
{: .notice--info}

## When to use models?

When should you be using `Learn` and when should you be using `Parse`? It all depends of your use case. The below lines should make you be able to choose the best tool, depending of the situation.

Use a `Learn` when:
* you have a testbed with multiple devices, running **different OS**,
* you want a single **consistent** output.

Use `Parse` when:
* you have a testbed with a **single OS**,
* you care about **efficiency** (remember, `Learn` will send multiple show-commands in order to always be consistent. It could take a long time if run of a big testbed.)

## Collecting and parsing a CLI output with pyATS libraries models

Now that we understand when to use `Learn` (models) and when to use `Parse`, let's look at the code. This script will collect the `Inteface` model of two devices. One running IOS XR, the other running IOS XE. It will extract the interface `name` and the interface `ip address` from the dictionary, then print each couple. The script  will be further detailed and explained below.

**2_multi_os.py**
{: .notice--primary}
<div class="highlight"><pre><span></span><span class="c1"># New module! Now using Genie!</span>
<span class="kn">from</span> <span class="nn">genie</span> <span class="kn">import</span> <span class="n">testbed</span>

<span class="c1"># Step 0: Load the testbed</span>
<span class="n">testbed</span> <span class="o">=</span> <span class="n">testbed</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;./testbed.yaml&#39;</span><span class="p">)</span>

<span class="c1"># Step 1: Iterate through each device in the testbed</span>
<span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="n">testbed</span><span class="p">:</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="c1"># Step 2: Connect on the device and print its name</span>
    <span class="n">device</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">init_exec_commands</span><span class="o">=</span><span class="p">[],</span> <span class="n">init_config_commands</span><span class="o">=</span><span class="p">[],</span> <span class="n">log_stdout</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-----------------------------------&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-- Connected on device: </span><span class="si">{device}</span><span class="s1"> --&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="o">.</span><span class="n">alias</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-----------------------------------&#39;</span><span class="p">)</span>

    <span class="c1"># Step 3: Learn interface model from the device</span>
    <span class="n">show_interface</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">learn</span><span class="p">(</span><span class="s1">&#39;interface&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">interface</span><span class="p">,</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">show_interface</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

        <span class="c1"># Step 4: What if the key &#39;ipv4&#39; doesn&#39;t exist (= no assigned IPv4)?</span>
        <span class="k">if</span> <span class="s1">&#39;ipv4&#39;</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ip</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;ipv4&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{interface}</span><span class="s1"> -- </span><span class="si">{ip}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">interface</span><span class="p">,</span> <span class="n">ip</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="s1">&#39;ip&#39;</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{interface}</span><span class="s1"> -- Unassigned&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">interface</span><span class="p">))</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="c1"># Step 5: Disconnect from the device</span>
    <span class="n">device</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span>
</pre></div>

The `2_multi_os.py` file is available [here](https://github.com/AntoineOrsoni/xrdocs-how-to-pyats/blob/master/2_multi_os/).
{: .notice--info}

### Executing the script

**From your bash terminal**
{: .notice--primary}
<div class="highlighter-rouge">
<pre class="highlight">
<code>
python 2_multi_os.py
</code>
</pre>
</div>

In this example, the `testbed.yaml` file need to be in the same folder as the `2_multi_os.py` file. Also, you need to execute the Python script in the folder where you have these two files.
{: .notice--info}

Let's now explain the building blocks of the Python script. The parts below will refer to each inline comment of the code block above.

### Output example

Here is an output example of the above script. It might slightly vary according to the configuration of the device.

**Python console**
{: .notice--primary}
<div class="highlighter-rouge">
<pre class="highlight">
<code>
---------------------------------
-- Connected on device: iosxr1 --
---------------------------------
Loopback200 -- 1.1.1.200
Loopback100 -- 1.1.1.100
GigabitEthernet0/0/0/6 -- Unassigned
GigabitEthernet0/0/0/5 -- Unassigned
GigabitEthernet0/0/0/4 -- Unassigned
GigabitEthernet0/0/0/3 -- Unassigned
GigabitEthernet0/0/0/2 -- Unassigned
GigabitEthernet0/0/0/1 -- Unassigned
GigabitEthernet0/0/0/0 -- Unassigned
MgmtEth0/RP0/CPU0/0 -- 10.10.20.175
Null0 -- Unassigned


-----------------------------------
-- Connected on device: csr1000v --
-----------------------------------
Loopback3 -- 8.8.8.8
GigabitEthernet3 -- 7.7.7.7
GigabitEthernet2 -- 10.10.10.1
GigabitEthernet1 -- 10.10.20.48
Loopback6 -- 99.99.48.20
Loopback5 -- 3.3.3.3
</code>
</pre>
</div>

### Step 0: load the testbed

From the `genie` module, we import the `testbed.load()` function. This function will be used to load the testbed file we have created.

We load the `testbed` information, stored in our `testbed.yaml` file. We assign it to an object: `testbed`.

### Step 1: iterate through each device in the testbed

`testbed` object has an `iterator` capability. When used, it returns each `device` object in the testbed. We will iterate through each device in the testbed, connect and populate our model.

### Step 2: connect to the device

We use the `connect()` method on the `iosxr1` object to connect to the device.

By default, pyATS will send exec and configuration commands to the device (such as `terminal length 0` and `show version`). To avoid such behavior, we are passing arguments to the `conect()` method. We are also disabling the logging to standard output.
More information in the [documentation].(https://pubhub.devnetcloud.com/media/unicon/docs/user_guide/connection.html)
{: .notice--info}

### Step 3: learn `interface` model from the device

This step is the most important step in our script. It will `Learn` the `interface` model. pyATS will send **multiple show-commands** to the device in order to fully populate the model. Each information of the CLI output will be mapped either as a dictionary key or a value. Because we need to have the same keys between models, there could be entropy loss between the raw CLI output and the parsed output. For example, if an operational data is unique to an OS.

To do so, we are using the `learn()` method on the `device` object. The `learn` method takes a string as parameter, which is the model we would like to collect and parse. We are saving this parsed output in a variable `show_interface`.

You can find all pyATS supported **models** in the [official documentation](https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/models).
{: .notice--info}

A parsed output example (i.e. the dictionary saved in the variable `show_interface`) can be seen in **Step 4**. 

### Step 4: Python logic to print interface name and IP

Below an example of parsed output for the `interface` model. Most interfaces are **missing** (only one is shown), for conciseness.

**Parsed CLI output**
{: .notice--primary}
<div class="highlighter-rouge">
<pre class="highlight">
<code>
{'GigabitEthernet0/0/0/0': {'bandwidth': 1000000,
                            'counters': {'in_broadcast_pkts': 0,
                                         'in_crc_errors': 0,
                                         'in_discards': 0,
                                         'in_multicast_pkts': 0,
                                         'in_octets': 0,
                                         'in_pkts': 0,
                                         'last_clear': 'never',
                                         'out_broadcast_pkts': 0,
                                         'out_errors': 0,
                                         'out_multicast_pkts': 0,
                                         'out_octets': 0,
                                         'out_pkts': 0,
                                         'rate': {'in_rate': 0,
                                                  'in_rate_pkts': 0,
                                                  'load_interval': 300,
                                                  'out_rate': 0,
                                                  'out_rate_pkts': 0}},
                            'enabled': False,
                            'encapsulation': {'encapsulation': 'arpa'},
                            'flow_control': {'flow_control_receive': False,
                                             'flow_control_send': False},
                            'ipv6': {'enabled': False},
                            'mac_address': '0050.56bb.4247',
                            'mtu': 1514,
                            'oper_status': 'down',
                            'phys_address': '0050.56bb.4247',
                            'type': 'gigabitethernet'}
</code>
</pre>
</div>

In the above output, we have a list of interfaces: `GigabitEthernet0/0/0/0` (others are **not** shown for conciseness). We are iterating through this list. For each interface, we are accessing the `ip_address` value. We're then printting the interface `name` and `IP`. 

The `info` attribute of the `Interface` object returns a Python dictionnary. We iterate through this dictionnary items. It returns all the `tuples` of `key: values` of this dictionnary.

It might not be useful in a real life use case. Goal here is to take a concise example, to show how easy it is to extract values of a CLI output when parsed with pyATS libraries.
{: .notice--info}

### Step 5: disconnect from the device

We use the `disconnect()` method to properly disconnect from the device. 

It’s important to properly disconnect from the device, otherwise the vty connection will remain open on the device, until it times out.
{: .notice--info}

# Conclusion

In this second episode of the pyATS series, we learnt:

- The difference between pyATS `Learn` and `Parse` capabilities,
- Why pyATS models are powerful,
- How to collect and parse a CLI output from multiple devices using pyATS `Learn`,
- How to get a value from a parsed output.

In the next post, we will see our first use case: how to collect many `show commands` on many devices. Stay tunned!

The code used for each blog post can be found [here](https://github.com/AntoineOrsoni/xrdocs-how-to-pyats). This link will include the code for all posts.
{: .notice--info}

# Resources

Below a few useful pyATS resources.

- [List of supported pyATS parsers](https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/),
- [The official pyATS documentation](https://pubhub.devnetcloud.com/media/pyats/docs/getting_started/index.html),
- [List of Unicon supported platforms](https://pubhub.devnetcloud.com/media/unicon/docs/user_guide/supported_platforms.html),
- [Devnet code exchange](https://developer.cisco.com/codeexchange/),
- [Join the Webex space with the pyATS community](https://eurl.io/#r18UzrQVr).
